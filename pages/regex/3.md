# 括号的作用

括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。  
引用某个分组，会有两种情形:在 JavaScript 里引用它，在正则表达式里引用它。

## 分组和分支结构

### 分组

我们知道 /a+/ 匹配连续出现的 "a"，而要匹配连续出现的 "ab" 时，需要使用 /(ab)+/。

其中括号是提供分组功能，使量词 + 作用于 "ab" 这个整体，测试如下:

```javascript
"abaa abab ba a aba aababaa".match(/(ab)+/g);
// ["ab", "abab", "ab", "abab"]
```

### 分支结构

而在多选分支结构 (p1|p2) 中，此处括号的作用也是不言而喻的，提供了分支表达式的所有可能。

比如，要匹配如下的字符串:

```javascript
// I love JavaScript
// I love Regular Expression
let reg = /^I love (JavaScript|Regular Expression)$/;
reg.test("I love JavaScript");
reg.test("I love Regular Expression");
```

## 分组引用

这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。

```javascript
const regex = /(\d{4})-(\d{2})-(\d{2})/;
```

### 提取数据

```javascript
"2017-06-12".match(/(\d{4})-(\d{2})-(\d{2})/);
// ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12", groups: undefined]
```

:::tip
match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组(括号里)匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match
返回的数组格式是不一样的。()
:::

另外也可以使用正则实例对象的 exec 方法:

```javascript
/(\d{4})-(\d{2})-(\d{2})/.exec("2017-06-12");
// ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12", groups: undefined]
```

同时，也可以使用构造函数的全局属性 $1 至 $9 来获取:

```javascript
/(\d{4})-(\d{2})-(\d{2})/.exec("2017-06-12");
// ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12", groups: undefined]
RegExp.$1;
// "2017"
RegExp.$2;
// "06"
RegExp.$3;
// "12"
```

### 替换数据

比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做?

```javascript
"2010-02-10".replace(/(\d{4})-(\d{2})-(\d{2})/, "$1/$2/$3");
// "2010/02/10"
```

## 反向引用

除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。

要求匹配以下三种情况

```
2016-06-12
2016/06/12
2016.06.12
```

你可能想到的正则是

```javascript
/\d{4}(-|\.|\/)\d{2}(-|\.|\/)\d{2}/.test("2020-01-11");
```

但也匹配 "2016-06/12" 这样的数据，就会存在问题。可以使用反向引用解决

```javascript
/\d{4}(-|\.|\/)\d{2}\1\d{2}/.test("2020.01.11");
```

注意里面的 \1，表示的引用之前的那个分组 (-|\/|\.)。不管它匹配到什么(比如 -)，\1 都匹配那个同 样的具体某个字符。

我们知道了 \1 的含义后，那么 \2 和 \3 的概念也就理解了，即分别指代第二个和第三个分组。

### 括号嵌套

看例子

```javascript
/^((\d)(\d(\d)))\1\2\3\4$/.test("1231231233");
RegExp.$1;
// "123"
RegExp.$2;
// "1"
RegExp.$3;
// "23"
RegExp.$4;
// "3"
```

分析

- 接下来的是 \1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是 "123"，
- 接下来的是 \2，找到第 2 个开括号，对应的分组，匹配的内容是 "1"，
- 接下来的是 \3，找到第 3 个开括号，对应的分组，匹配的内容是 "23"，
- 最后的是 \4，找到第 3 个开括号，对应的分组，匹配的内容是 "3"。

### \10 表示什么呢

\10 是表示第 10 个分组，还是 \1 和 0 呢?

答案是前者，虽然一个正则里出现 \10 比较罕见。测试如下:

```javascript
/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/.test("123456789# ######"); // true
```

:::tip
如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0)。  
`(?:)` 表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
:::

### 分组后面有量词会怎样?

分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。比如如下的测试案例:

```javascript
"12345".match(/(\d)+/);
// ["12345", "5", index: 0, input: "12345", groups: undefined]0: "12345"1: "5"groups: undefinedindex: 0input: "12345"length: 2__proto__: Array(0)
RegExp.$1;
// "5"
RegExp.$2;
// ""
```

对于反向引用，同理

```javascript
var regex = /(\d)+ \1/;
console.log(regex.test("12345 1")); // => false
console.log(regex.test("12345 5")); // => true
```

## 案例分析

### 字符串 trim 方法模拟

```javascript
"  dad ad  ".replace(/^\s*|\s*$/g, "");
// "dad ad"

"  dad ad  ".replace(/^\s*(.*?)\s*$/g, "$1");
// "dad ad"
```

:::tip
这里使用了惰性匹配 \*?，不然也会匹配最后一个空格之前的所有空格的。
:::

### 将每个单词的首字母转换为大写

```javascript
"my name is epeli".replace(/(^|\s)([a-z])/g, (a, b, c) => {
  return a.toUpperCase();
});
// "My Name Is Epeli"
```

### 驼峰化

```javascript
"abc-moz-transform".replace(/(^|-)(\w)/g, (a, b, c) => {
  return c.toUpperCase();
});
// "AbcMozTransform"
```

### 匹配成对标签

匹配一个开标签

```javascript
/^<\w+>$/g.test("<asddasd>");
```

匹配一个闭标签

```javascript
/^<\/\w+>$/g.test("</asddasd>");
```

匹配一个完整的闭合标签

```javascript
/^<(\w+)>.+<\/\1>$/g.test("<asddasd>adasd</asddasd>");
```

`<(\w+)>`使用括号的目的是为了后面的`\1`反向引用
